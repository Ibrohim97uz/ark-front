{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Ibrohim\\\\Desktop\\\\ark-front\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:\\\\Users\\\\Ibrohim\\\\Desktop\\\\ark-front\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Ibrohim\\\\Desktop\\\\ark-front\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DEFAULT_PLACEHOLDER_CHAR, mergeFormatCharacters } from './helpers';\nimport { Pattern } from './Pattern';\nexport var InputMask = /*#__PURE__*/function () {\n  function InputMask(options) {\n    _classCallCheck(this, InputMask);\n\n    this.emptyValue = '';\n    this._history = [];\n    this._historyIndex = null;\n    this._lastOp = null;\n    this._lastSelection = null;\n\n    var mergedOptions = _objectSpread(_objectSpread({}, {\n      isRevealingMask: false,\n      placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n      selection: {\n        start: 0,\n        end: 0\n      },\n      value: ''\n    }), options);\n\n    if (!mergedOptions.pattern) {\n      throw new Error('InputMask: you must provide a pattern.');\n    }\n\n    if (typeof mergedOptions.placeholderChar !== 'string' || mergedOptions.placeholderChar.length > 1) {\n      throw new Error('InputMask: placeholderChar should be a single character or an empty string.');\n    }\n\n    this.placeholderChar = mergedOptions.placeholderChar;\n    this.formatCharacters = mergeFormatCharacters(mergedOptions.formatCharacters);\n    this.setPattern(mergedOptions.pattern, {\n      value: mergedOptions.value,\n      selection: mergedOptions.selection,\n      isRevealingMask: mergedOptions.isRevealingMask\n    });\n  }\n\n  _createClass(InputMask, [{\n    key: \"setPattern\",\n    value: function setPattern(patternSource, options) {\n      var merged = _objectSpread({\n        selection: {\n          start: 0,\n          end: 0\n        },\n        value: ''\n      }, options);\n\n      this.pattern = new Pattern(patternSource, this.formatCharacters, this.placeholderChar, merged.isRevealingMask);\n      this.setValue(merged.value);\n      this.emptyValue = this.pattern.formatValue([]).join('');\n      this.selection = merged.selection;\n\n      this._resetHistory();\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (value == null) {\n        value = '';\n      }\n\n      this.value = this.pattern.formatValue(value.split(''));\n    }\n  }, {\n    key: \"_resetHistory\",\n    value: function _resetHistory() {\n      this._history = [];\n      this._historyIndex = null;\n      this._lastOp = null;\n      this._lastSelection = _objectSpread({}, this.selection);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (this.pattern.isRevealingMask) {\n        this.value = this.pattern.formatValue(this.getRawValue().split(''));\n      }\n\n      return this.value.join('');\n    }\n  }, {\n    key: \"getRawValue\",\n    value: function getRawValue() {\n      var rawValue = [];\n\n      for (var i = 0; i < this.value.length; i++) {\n        if (this.pattern._editableIndices[i] === true) {\n          rawValue.push(this.value[i]);\n        }\n      }\n\n      return rawValue.join('');\n    }\n    /**\n     * Applies a single character of input based on the current selection.\n     * @param {string} char\n     * @return {boolean} true if a change has been made to value or selection as a\n     *   result of the input, false otherwise.\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(char) {\n      // Ignore additional input if the cursor's at the end of the pattern\n      if (this.selection.start === this.selection.end && this.selection.start === this.pattern.length) {\n        return false;\n      }\n\n      var selectionBefore = _objectSpread({}, this.selection);\n\n      var valueBefore = this.getValue();\n      var inputIndex = this.selection.start; // If the cursor or selection is prior to the first editable character, make\n      // sure any input given is applied to it.\n\n      if (inputIndex < this.pattern.firstEditableIndex) {\n        inputIndex = this.pattern.firstEditableIndex;\n      } // Bail out or add the character to input\n\n\n      if (this.pattern.isEditableIndex(inputIndex)) {\n        if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n          return false;\n        }\n\n        this.value[inputIndex] = this.pattern.transform(char, inputIndex);\n      } // If multiple characters were selected, blank the remainder out based on the\n      // pattern.\n\n\n      var end = this.selection.end - 1;\n\n      while (end > inputIndex) {\n        if (this.pattern.isEditableIndex(end)) {\n          this.value[end] = this.placeholderChar;\n        }\n\n        end--;\n      } // Advance the cursor to the next character\n\n\n      this.selection.start = this.selection.end = inputIndex + 1; // Skip over any subsequent static characters\n\n      while (this.pattern.length > this.selection.start && !this.pattern.isEditableIndex(this.selection.start)) {\n        this.selection.start++;\n        this.selection.end++;\n      } // History\n\n\n      if (this._historyIndex != null) {\n        // Took more input after undoing, so blow any subsequent history away\n        this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n\n        this._historyIndex = null;\n      }\n\n      if (this._lastOp !== 'input' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n        this._history.push({\n          value: valueBefore,\n          selection: selectionBefore,\n          lastOp: this._lastOp\n        });\n      }\n\n      this._lastOp = 'input';\n      this._lastSelection = _objectSpread({}, this.selection);\n      return true;\n    }\n    /**\n     * Attempts to delete from the value based on the current cursor position or\n     * selection.\n     * @return {boolean} true if the value or selection changed as the result of\n     *   backspacing, false otherwise.\n     */\n\n  }, {\n    key: \"backspace\",\n    value: function backspace() {\n      // If the cursor is at the start there's nothing to do\n      if (this.selection.start === 0 && this.selection.end === 0) {\n        return false;\n      }\n\n      var selectionBefore = _objectSpread({}, this.selection);\n\n      var valueBefore = this.getValue(); // No range selected - work on the character preceding the cursor\n\n      if (this.selection.start === this.selection.end) {\n        if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n          if (this.pattern.isRevealingMask) {\n            this.value.splice(this.selection.start - 1);\n          } else {\n            this.value[this.selection.start - 1] = this.placeholderChar;\n          }\n        }\n\n        this.selection.start--;\n        this.selection.end--;\n      } // Range selected - delete characters and leave the cursor at the start of the selection\n      else {\n        var end = this.selection.end - 1;\n\n        while (end >= this.selection.start) {\n          if (this.pattern.isEditableIndex(end)) {\n            this.value[end] = this.placeholderChar;\n          }\n\n          end--;\n        }\n\n        this.selection.end = this.selection.start;\n      } // History\n\n\n      if (this._historyIndex != null) {\n        // Took more input after undoing, so blow any subsequent history away\n        this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n      }\n\n      if (this._lastOp !== 'backspace' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n        this._history.push({\n          value: valueBefore,\n          selection: selectionBefore,\n          lastOp: this._lastOp\n        });\n      }\n\n      this._lastOp = 'backspace';\n      this._lastSelection = _objectSpread({}, this.selection);\n      return true;\n    }\n    /**\n     * Attempts to paste a string of input at the current cursor position or over\n     * the top of the current selection.\n     * Invalid content at any position will cause the paste to be rejected, and it\n     * may contain static parts of the mask's pattern.\n     * @param {string} input\n     * @return {boolean} true if the paste was successful, false otherwise.\n     */\n\n  }, {\n    key: \"paste\",\n    value: function paste(input) {\n      var _this = this;\n\n      // This is necessary because we're just calling input() with each character\n      // and rolling back if any were invalid, rather than checking up-front.\n      var initialState = {\n        value: this.value.slice(),\n        selection: _objectSpread({}, this.selection),\n        _lastOp: this._lastOp,\n        _history: this._history.slice(),\n        _historyIndex: this._historyIndex,\n        _lastSelection: _objectSpread({}, this._lastSelection)\n      }; // If there are static characters at the start of the pattern and the cursor\n      // or selection is within them, the static characters must match for a valid\n      // paste.\n\n      if (this.selection.start < this.pattern.firstEditableIndex) {\n        for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n          if (input.charAt(i) !== this.pattern.pattern[i]) {\n            return false;\n          }\n        } // Continue as if the selection and input started from the editable part of\n        // the pattern.\n\n\n        input = input.substring(this.pattern.firstEditableIndex - this.selection.start);\n        this.selection.start = this.pattern.firstEditableIndex;\n      }\n\n      for (i = 0, l = input.length; i < l && this.selection.start <= this.pattern.lastEditableIndex; i++) {\n        var valid = this.input(input.charAt(i)); // Allow static parts of the pattern to appear in pasted input - they will\n        // already have been stepped over by input(), so verify that the value\n        // deemed invalid by input() was the expected static character.\n\n        if (!valid) {\n          if (this.selection.start > 0) {\n            // XXX This only allows for one static character to be skipped\n            var patternIndex = this.selection.start - 1;\n\n            if (!this.pattern.isEditableIndex(patternIndex) && input.charAt(i) === this.pattern.pattern[patternIndex]) {\n              continue;\n            }\n          }\n\n          Object.keys(initialState).forEach(function (key) {\n            // @ts-ignore\n            _this[key] = initialState[key];\n          });\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      // If there is no history, or nothing more on the history stack, we can't undo\n      if (this._history.length === 0 || this._historyIndex === 0) {\n        return false;\n      }\n\n      var historyItem;\n\n      if (this._historyIndex == null) {\n        // Not currently undoing, set up the initial history index\n        this._historyIndex = this._history.length - 1;\n        historyItem = this._history[this._historyIndex]; // Add a new history entry if anything has changed since the last one, so we\n        // can redo back to the initial state we started undoing from.\n\n        var value = this.getValue();\n\n        if (historyItem.value !== value || historyItem.selection.start !== this.selection.start || historyItem.selection.end !== this.selection.end) {\n          this._history.push({\n            value: value,\n            selection: _objectSpread({}, this.selection),\n            lastOp: this._lastOp,\n            startUndo: true\n          });\n        }\n      } else {\n        historyItem = this._history[--this._historyIndex];\n      }\n\n      this.value = historyItem.value.split('');\n      this.selection = historyItem.selection;\n      this._lastOp = historyItem.lastOp;\n      return true;\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      if (this._history.length === 0 || this._historyIndex == null) {\n        return false;\n      }\n\n      var historyItem = this._history[++this._historyIndex]; // If this is the last history item, we're done redoing\n\n      if (this._historyIndex === this._history.length - 1) {\n        this._historyIndex = null; // If the last history item was only added to start undoing, remove it\n\n        if (historyItem.startUndo) {\n          this._history.pop();\n        }\n      }\n\n      this.value = historyItem.value.split('');\n      this.selection = historyItem.selection;\n      this._lastOp = historyItem.lastOp;\n      return true;\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      this.selection = _objectSpread({}, selection);\n\n      if (this.selection.start === this.selection.end) {\n        if (this.selection.start < this.pattern.firstEditableIndex) {\n          this.selection.start = this.selection.end = this.pattern.firstEditableIndex;\n          return true;\n        } // Set selection to the first editable, non-placeholder character before the selection\n        // OR to the beginning of the pattern\n\n\n        var index = this.selection.start;\n\n        while (index >= this.pattern.firstEditableIndex) {\n          if (this.pattern.isEditableIndex(index - 1) && this.value[index - 1] !== this.placeholderChar || index === this.pattern.firstEditableIndex) {\n            this.selection.start = this.selection.end = index;\n            break;\n          }\n\n          index--;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return InputMask;\n}();\nInputMask.Pattern = Pattern;\nexport default InputMask;","map":{"version":3,"sources":["../../../src/lib/inputmask-core.ts"],"names":[],"mappings":";;;AAAA,SAAS,wBAAT,EAAqD,qBAArD,QAAkF,WAAlF;AACA,SAAS,OAAT,QAAwB,WAAxB;AAaA,WAAa,SAAb;AAqBE,qBAAY,OAAZ,EAAqC;AAAA;;AAZrC,SAAA,UAAA,GAAa,EAAb;AAEA,SAAA,QAAA,GAKM,EALN;AAMA,SAAA,aAAA,GAA+B,IAA/B;AACA,SAAA,OAAA,GAAyB,IAAzB;AACA,SAAA,cAAA,GAAyC,IAAzC;;AAGE,QAAM,aAAa,mCACd;AACD,MAAA,eAAe,EAAE,KADhB;AAED,MAAA,eAAe,EAAE,wBAFhB;AAGD,MAAA,SAAS,EAAE;AAAE,QAAA,KAAK,EAAE,CAAT;AAAY,QAAA,GAAG,EAAE;AAAjB,OAHV;AAID,MAAA,KAAK,EAAE;AAJN,KADc,GAOd,OAPc,CAAnB;;AAUA,QAAI,CAAC,aAAa,CAAC,OAAnB,EAA4B;AAC1B,YAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,QACE,OAAO,aAAa,CAAC,eAArB,KAAyC,QAAzC,IACA,aAAa,CAAC,eAAd,CAA8B,MAA9B,GAAuC,CAFzC,EAGE;AACA,YAAM,IAAI,KAAJ,CACJ,6EADI,CAAN;AAGD;;AAED,SAAK,eAAL,GAAuB,aAAa,CAAC,eAArC;AACA,SAAK,gBAAL,GAAwB,qBAAqB,CAAC,aAAa,CAAC,gBAAf,CAA7C;AAEA,SAAK,UAAL,CAAgB,aAAa,CAAC,OAA9B,EAAuC;AACrC,MAAA,KAAK,EAAE,aAAa,CAAC,KADgB;AAErC,MAAA,SAAS,EAAE,aAAa,CAAC,SAFY;AAGrC,MAAA,eAAe,EAAE,aAAa,CAAC;AAHM,KAAvC;AAKD;;AArDH;AAAA;AAAA,WAuDE,oBAAW,aAAX,EAAkC,OAAlC,EAA2D;AACzD,UAAM,MAAM;AACV,QAAA,SAAS,EAAE;AAAE,UAAA,KAAK,EAAE,CAAT;AAAY,UAAA,GAAG,EAAE;AAAjB,SADD;AAEV,QAAA,KAAK,EAAE;AAFG,SAGP,OAHO,CAAZ;;AAMA,WAAK,OAAL,GAAe,IAAI,OAAJ,CACb,aADa,EAEb,KAAK,gBAFQ,EAGb,KAAK,eAHQ,EAIb,MAAM,CAAC,eAJM,CAAf;AAOA,WAAK,QAAL,CAAc,MAAM,CAAC,KAArB;AAEA,WAAK,UAAL,GAAkB,KAAK,OAAL,CAAa,WAAb,CAAyB,EAAzB,EAA6B,IAA7B,CAAkC,EAAlC,CAAlB;AACA,WAAK,SAAL,GAAiB,MAAM,CAAC,SAAxB;;AACA,WAAK,aAAL;AACD;AA1EH;AAAA;AAAA,WA4EE,kBAAS,KAAT,EAAuB;AACrB,UAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,QAAA,KAAK,GAAG,EAAR;AACD;;AACD,WAAK,KAAL,GAAa,KAAK,OAAL,CAAa,WAAb,CAAyB,KAAK,CAAC,KAAN,CAAY,EAAZ,CAAzB,CAAb;AACD;AAjFH;AAAA;AAAA,WAmFE,yBAAa;AACX,WAAK,QAAL,GAAgB,EAAhB;AACA,WAAK,aAAL,GAAqB,IAArB;AACA,WAAK,OAAL,GAAe,IAAf;AACA,WAAK,cAAL,qBAA2B,KAAK,SAAhC;AACD;AAxFH;AAAA;AAAA,WA0FE,oBAAQ;AACN,UAAI,KAAK,OAAL,CAAa,eAAjB,EAAkC;AAChC,aAAK,KAAL,GAAa,KAAK,OAAL,CAAa,WAAb,CAAyB,KAAK,WAAL,GAAmB,KAAnB,CAAyB,EAAzB,CAAzB,CAAb;AACD;;AACD,aAAO,KAAK,KAAL,CAAW,IAAX,CAAgB,EAAhB,CAAP;AACD;AA/FH;AAAA;AAAA,WAiGE,uBAAW;AACT,UAAI,QAAQ,GAAG,EAAf;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,KAAL,CAAW,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,YAAI,KAAK,OAAL,CAAa,gBAAb,CAA8B,CAA9B,MAAqC,IAAzC,EAA+C;AAC7C,UAAA,QAAQ,CAAC,IAAT,CAAc,KAAK,KAAL,CAAW,CAAX,CAAd;AACD;AACF;;AACD,aAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACD;AAED;;;;;AAKG;;AAhHL;AAAA;AAAA,WAiHE,eAAM,IAAN,EAAkB;AAChB;AACA,UACE,KAAK,SAAL,CAAe,KAAf,KAAyB,KAAK,SAAL,CAAe,GAAxC,IACA,KAAK,SAAL,CAAe,KAAf,KAAyB,KAAK,OAAL,CAAa,MAFxC,EAGE;AACA,eAAO,KAAP;AACD;;AAED,UAAI,eAAe,qBAAQ,KAAK,SAAb,CAAnB;;AACA,UAAI,WAAW,GAAG,KAAK,QAAL,EAAlB;AAEA,UAAI,UAAU,GAAG,KAAK,SAAL,CAAe,KAAhC,CAZgB,CAchB;AACA;;AACA,UAAI,UAAU,GAAG,KAAK,OAAL,CAAa,kBAA9B,EAAmD;AACjD,QAAA,UAAU,GAAG,KAAK,OAAL,CAAa,kBAA1B;AACD,OAlBe,CAoBhB;;;AACA,UAAI,KAAK,OAAL,CAAa,eAAb,CAA6B,UAA7B,CAAJ,EAA8C;AAC5C,YAAI,CAAC,KAAK,OAAL,CAAa,cAAb,CAA4B,IAA5B,EAAkC,UAAlC,CAAL,EAAoD;AAClD,iBAAO,KAAP;AACD;;AACD,aAAK,KAAL,CAAW,UAAX,IAAyB,KAAK,OAAL,CAAa,SAAb,CAAuB,IAAvB,EAA6B,UAA7B,CAAzB;AACD,OA1Be,CA4BhB;AACA;;;AACA,UAAI,GAAG,GAAG,KAAK,SAAL,CAAe,GAAf,GAAqB,CAA/B;;AACA,aAAO,GAAG,GAAG,UAAb,EAAyB;AACvB,YAAI,KAAK,OAAL,CAAa,eAAb,CAA6B,GAA7B,CAAJ,EAAuC;AACrC,eAAK,KAAL,CAAW,GAAX,IAAkB,KAAK,eAAvB;AACD;;AACD,QAAA,GAAG;AACJ,OApCe,CAsChB;;;AACA,WAAK,SAAL,CAAe,KAAf,GAAuB,KAAK,SAAL,CAAe,GAAf,GAAqB,UAAU,GAAG,CAAzD,CAvCgB,CAyChB;;AACA,aACE,KAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,SAAL,CAAe,KAArC,IACA,CAAC,KAAK,OAAL,CAAa,eAAb,CAA6B,KAAK,SAAL,CAAe,KAA5C,CAFH,EAGE;AACA,aAAK,SAAL,CAAe,KAAf;AACA,aAAK,SAAL,CAAe,GAAf;AACD,OAhDe,CAkDhB;;;AACA,UAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B;AACA,aAAK,QAAL,CAAc,MAAd,CAAqB,KAAK,aAA1B,EAAyC,KAAK,QAAL,CAAc,MAAd,GAAuB,KAAK,aAArE;;AACA,aAAK,aAAL,GAAqB,IAArB;AACD;;AACD,UACE,KAAK,OAAL,KAAiB,OAAjB,IACA,eAAe,CAAC,KAAhB,KAA0B,eAAe,CAAC,GAD1C,IAEC,KAAK,cAAL,KAAwB,IAAxB,IAAgC,eAAe,CAAC,KAAhB,KAA0B,KAAK,cAAL,CAAoB,KAHjF,EAIE;AACA,aAAK,QAAL,CAAc,IAAd,CAAmB;AAAE,UAAA,KAAK,EAAE,WAAT;AAAsB,UAAA,SAAS,EAAE,eAAjC;AAAkD,UAAA,MAAM,EAAE,KAAK;AAA/D,SAAnB;AACD;;AACD,WAAK,OAAL,GAAe,OAAf;AACA,WAAK,cAAL,qBAA2B,KAAK,SAAhC;AAEA,aAAO,IAAP;AACD;AAED;;;;;AAKG;;AA3LL;AAAA;AAAA,WA4LE,qBAAS;AACP;AACA,UAAI,KAAK,SAAL,CAAe,KAAf,KAAyB,CAAzB,IAA8B,KAAK,SAAL,CAAe,GAAf,KAAuB,CAAzD,EAA4D;AAC1D,eAAO,KAAP;AACD;;AAED,UAAI,eAAe,qBAAQ,KAAK,SAAb,CAAnB;;AACA,UAAI,WAAW,GAAG,KAAK,QAAL,EAAlB,CAPO,CASP;;AACA,UAAI,KAAK,SAAL,CAAe,KAAf,KAAyB,KAAK,SAAL,CAAe,GAA5C,EAAiD;AAC/C,YAAI,KAAK,OAAL,CAAa,eAAb,CAA6B,KAAK,SAAL,CAAe,KAAf,GAAuB,CAApD,CAAJ,EAA4D;AAC1D,cAAI,KAAK,OAAL,CAAa,eAAjB,EAAkC;AAChC,iBAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,SAAL,CAAe,KAAf,GAAuB,CAAzC;AACD,WAFD,MAEO;AACL,iBAAK,KAAL,CAAW,KAAK,SAAL,CAAe,KAAf,GAAuB,CAAlC,IAAuC,KAAK,eAA5C;AACD;AACF;;AACD,aAAK,SAAL,CAAe,KAAf;AACA,aAAK,SAAL,CAAe,GAAf;AACD,OAVD,CAWA;AAXA,WAYK;AACH,YAAI,GAAG,GAAG,KAAK,SAAL,CAAe,GAAf,GAAqB,CAA/B;;AACA,eAAO,GAAG,IAAI,KAAK,SAAL,CAAe,KAA7B,EAAoC;AAClC,cAAI,KAAK,OAAL,CAAa,eAAb,CAA6B,GAA7B,CAAJ,EAAuC;AACrC,iBAAK,KAAL,CAAW,GAAX,IAAkB,KAAK,eAAvB;AACD;;AACD,UAAA,GAAG;AACJ;;AACD,aAAK,SAAL,CAAe,GAAf,GAAqB,KAAK,SAAL,CAAe,KAApC;AACD,OA/BM,CAiCP;;;AACA,UAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B;AACA,aAAK,QAAL,CAAc,MAAd,CAAqB,KAAK,aAA1B,EAAyC,KAAK,QAAL,CAAc,MAAd,GAAuB,KAAK,aAArE;AACD;;AACD,UACE,KAAK,OAAL,KAAiB,WAAjB,IACA,eAAe,CAAC,KAAhB,KAA0B,eAAe,CAAC,GAD1C,IAEC,KAAK,cAAL,KAAwB,IAAxB,IAAgC,eAAe,CAAC,KAAhB,KAA0B,KAAK,cAAL,CAAoB,KAHjF,EAIE;AACA,aAAK,QAAL,CAAc,IAAd,CAAmB;AAAE,UAAA,KAAK,EAAE,WAAT;AAAsB,UAAA,SAAS,EAAE,eAAjC;AAAkD,UAAA,MAAM,EAAE,KAAK;AAA/D,SAAnB;AACD;;AACD,WAAK,OAAL,GAAe,WAAf;AACA,WAAK,cAAL,qBAA2B,KAAK,SAAhC;AAEA,aAAO,IAAP;AACD;AAED;;;;;;;AAOG;;AAtPL;AAAA;AAAA,WAuPE,eAAM,KAAN,EAAmB;AAAA;;AACjB;AACA;AACA,UAAI,YAAY,GAAG;AACjB,QAAA,KAAK,EAAE,KAAK,KAAL,CAAW,KAAX,EADU;AAEjB,QAAA,SAAS,oBAAO,KAAK,SAAZ,CAFQ;AAGjB,QAAA,OAAO,EAAE,KAAK,OAHG;AAIjB,QAAA,QAAQ,EAAE,KAAK,QAAL,CAAc,KAAd,EAJO;AAKjB,QAAA,aAAa,EAAE,KAAK,aALH;AAMjB,QAAA,cAAc,oBAAO,KAAK,cAAZ;AANG,OAAnB,CAHiB,CAYjB;AACA;AACA;;AACA,UAAI,KAAK,SAAL,CAAe,KAAf,GAAuB,KAAK,OAAL,CAAa,kBAAxC,EAA6D;AAC3D,aAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,KAAK,OAAL,CAAa,kBAAb,GAAmC,KAAK,SAAL,CAAe,KAAtE,EAA6E,CAAC,GAAG,CAAjF,EAAoF,CAAC,EAArF,EAAyF;AACvF,cAAI,KAAK,CAAC,MAAN,CAAa,CAAb,MAAoB,KAAK,OAAL,CAAa,OAAb,CAAqB,CAArB,CAAxB,EAAiD;AAC/C,mBAAO,KAAP;AACD;AACF,SAL0D,CAO3D;AACA;;;AACA,QAAA,KAAK,GAAG,KAAK,CAAC,SAAN,CAAgB,KAAK,OAAL,CAAa,kBAAb,GAAmC,KAAK,SAAL,CAAe,KAAlE,CAAR;AACA,aAAK,SAAL,CAAe,KAAf,GAAuB,KAAK,OAAL,CAAa,kBAApC;AACD;;AAED,WACE,CAAC,GAAG,CAAJ,EAAO,CAAC,GAAG,KAAK,CAAC,MADnB,EAEE,CAAC,GAAG,CAAJ,IAAS,KAAK,SAAL,CAAe,KAAf,IAAwB,KAAK,OAAL,CAAa,iBAFhD,EAGE,CAAC,EAHH,EAIE;AACA,YAAI,KAAK,GAAG,KAAK,KAAL,CAAW,KAAK,CAAC,MAAN,CAAa,CAAb,CAAX,CAAZ,CADA,CAEA;AACA;AACA;;AACA,YAAI,CAAC,KAAL,EAAY;AACV,cAAI,KAAK,SAAL,CAAe,KAAf,GAAuB,CAA3B,EAA8B;AAC5B;AACA,gBAAI,YAAY,GAAG,KAAK,SAAL,CAAe,KAAf,GAAuB,CAA1C;;AACA,gBACE,CAAC,KAAK,OAAL,CAAa,eAAb,CAA6B,YAA7B,CAAD,IACA,KAAK,CAAC,MAAN,CAAa,CAAb,MAAoB,KAAK,OAAL,CAAa,OAAb,CAAqB,YAArB,CAFtB,EAGE;AACA;AACD;AACF;;AAED,UAAA,MAAM,CAAC,IAAP,CAAY,YAAZ,EAA0B,OAA1B,CAAkC,UAAA,GAAG,EAAG;AACtC;AACA,YAAA,KAAI,CAAC,GAAD,CAAJ,GAAY,YAAY,CAAC,GAAD,CAAxB;AACD,WAHD;AAKA,iBAAO,KAAP;AACD;AACF;;AAED,aAAO,IAAP;AACD;AAlTH;AAAA;AAAA,WAoTE,gBAAI;AACF;AACA,UAAI,KAAK,QAAL,CAAc,MAAd,KAAyB,CAAzB,IAA8B,KAAK,aAAL,KAAuB,CAAzD,EAA4D;AAC1D,eAAO,KAAP;AACD;;AAED,UAAI,WAAJ;;AACA,UAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B;AACA,aAAK,aAAL,GAAqB,KAAK,QAAL,CAAc,MAAd,GAAuB,CAA5C;AACA,QAAA,WAAW,GAAG,KAAK,QAAL,CAAc,KAAK,aAAnB,CAAd,CAH8B,CAI9B;AACA;;AACA,YAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AACA,YACE,WAAW,CAAC,KAAZ,KAAsB,KAAtB,IACA,WAAW,CAAC,SAAZ,CAAsB,KAAtB,KAAgC,KAAK,SAAL,CAAe,KAD/C,IAEA,WAAW,CAAC,SAAZ,CAAsB,GAAtB,KAA8B,KAAK,SAAL,CAAe,GAH/C,EAIE;AACA,eAAK,QAAL,CAAc,IAAd,CAAmB;AACjB,YAAA,KAAK,EAAE,KADU;AAEjB,YAAA,SAAS,oBAAO,KAAK,SAAZ,CAFQ;AAGjB,YAAA,MAAM,EAAE,KAAK,OAHI;AAIjB,YAAA,SAAS,EAAE;AAJM,WAAnB;AAMD;AACF,OAnBD,MAmBO;AACL,QAAA,WAAW,GAAG,KAAK,QAAL,CAAc,EAAE,KAAK,aAArB,CAAd;AACD;;AAED,WAAK,KAAL,GAAa,WAAW,CAAC,KAAZ,CAAkB,KAAlB,CAAwB,EAAxB,CAAb;AACA,WAAK,SAAL,GAAiB,WAAW,CAAC,SAA7B;AACA,WAAK,OAAL,GAAe,WAAW,CAAC,MAA3B;AACA,aAAO,IAAP;AACD;AAtVH;AAAA;AAAA,WAwVE,gBAAI;AACF,UAAI,KAAK,QAAL,CAAc,MAAd,KAAyB,CAAzB,IAA8B,KAAK,aAAL,IAAsB,IAAxD,EAA8D;AAC5D,eAAO,KAAP;AACD;;AACD,UAAI,WAAW,GAAG,KAAK,QAAL,CAAc,EAAE,KAAK,aAArB,CAAlB,CAJE,CAKF;;AACA,UAAI,KAAK,aAAL,KAAuB,KAAK,QAAL,CAAc,MAAd,GAAuB,CAAlD,EAAqD;AACnD,aAAK,aAAL,GAAqB,IAArB,CADmD,CAEnD;;AACA,YAAI,WAAW,CAAC,SAAhB,EAA2B;AACzB,eAAK,QAAL,CAAc,GAAd;AACD;AACF;;AACD,WAAK,KAAL,GAAa,WAAW,CAAC,KAAZ,CAAkB,KAAlB,CAAwB,EAAxB,CAAb;AACA,WAAK,SAAL,GAAiB,WAAW,CAAC,SAA7B;AACA,WAAK,OAAL,GAAe,WAAW,CAAC,MAA3B;AACA,aAAO,IAAP;AACD;AAzWH;AAAA;AAAA,WA2WE,sBAAa,SAAb,EAAuC;AACrC,WAAK,SAAL,qBAAsB,SAAtB;;AAEA,UAAI,KAAK,SAAL,CAAe,KAAf,KAAyB,KAAK,SAAL,CAAe,GAA5C,EAAiD;AAC/C,YAAI,KAAK,SAAL,CAAe,KAAf,GAAuB,KAAK,OAAL,CAAa,kBAAxC,EAA6D;AAC3D,eAAK,SAAL,CAAgB,KAAhB,GAAwB,KAAK,SAAL,CAAgB,GAAhB,GAAsB,KAAK,OAAL,CAAa,kBAA3D;AACA,iBAAO,IAAP;AACD,SAJ8C,CAK/C;AACA;;;AACA,YAAI,KAAK,GAAG,KAAK,SAAL,CAAe,KAA3B;;AACA,eAAO,KAAK,IAAI,KAAK,OAAL,CAAa,kBAA7B,EAAkD;AAChD,cACG,KAAK,OAAL,CAAa,eAAb,CAA6B,KAAK,GAAG,CAArC,KACC,KAAK,KAAL,CAAW,KAAK,GAAG,CAAnB,MAA0B,KAAK,eADjC,IAEA,KAAK,KAAK,KAAK,OAAL,CAAa,kBAHzB,EAIE;AACA,iBAAK,SAAL,CAAe,KAAf,GAAuB,KAAK,SAAL,CAAe,GAAf,GAAqB,KAA5C;AACA;AACD;;AACD,UAAA,KAAK;AACN;;AACD,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;AApYH;;AAAA;AAAA;AACS,SAAA,CAAA,OAAA,GAAU,OAAV;AAsYT,eAAe,SAAf","sourceRoot":"","sourcesContent":["import { DEFAULT_PLACEHOLDER_CHAR, mergeFormatCharacters } from './helpers';\nimport { Pattern } from './Pattern';\nexport class InputMask {\n    constructor(options) {\n        this.emptyValue = '';\n        this._history = [];\n        this._historyIndex = null;\n        this._lastOp = null;\n        this._lastSelection = null;\n        const mergedOptions = {\n            ...{\n                isRevealingMask: false,\n                placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n                selection: { start: 0, end: 0 },\n                value: '',\n            },\n            ...options,\n        };\n        if (!mergedOptions.pattern) {\n            throw new Error('InputMask: you must provide a pattern.');\n        }\n        if (typeof mergedOptions.placeholderChar !== 'string' ||\n            mergedOptions.placeholderChar.length > 1) {\n            throw new Error('InputMask: placeholderChar should be a single character or an empty string.');\n        }\n        this.placeholderChar = mergedOptions.placeholderChar;\n        this.formatCharacters = mergeFormatCharacters(mergedOptions.formatCharacters);\n        this.setPattern(mergedOptions.pattern, {\n            value: mergedOptions.value,\n            selection: mergedOptions.selection,\n            isRevealingMask: mergedOptions.isRevealingMask,\n        });\n    }\n    setPattern(patternSource, options) {\n        const merged = {\n            selection: { start: 0, end: 0 },\n            value: '',\n            ...options,\n        };\n        this.pattern = new Pattern(patternSource, this.formatCharacters, this.placeholderChar, merged.isRevealingMask);\n        this.setValue(merged.value);\n        this.emptyValue = this.pattern.formatValue([]).join('');\n        this.selection = merged.selection;\n        this._resetHistory();\n    }\n    setValue(value) {\n        if (value == null) {\n            value = '';\n        }\n        this.value = this.pattern.formatValue(value.split(''));\n    }\n    _resetHistory() {\n        this._history = [];\n        this._historyIndex = null;\n        this._lastOp = null;\n        this._lastSelection = { ...this.selection };\n    }\n    getValue() {\n        if (this.pattern.isRevealingMask) {\n            this.value = this.pattern.formatValue(this.getRawValue().split(''));\n        }\n        return this.value.join('');\n    }\n    getRawValue() {\n        var rawValue = [];\n        for (var i = 0; i < this.value.length; i++) {\n            if (this.pattern._editableIndices[i] === true) {\n                rawValue.push(this.value[i]);\n            }\n        }\n        return rawValue.join('');\n    }\n    /**\n     * Applies a single character of input based on the current selection.\n     * @param {string} char\n     * @return {boolean} true if a change has been made to value or selection as a\n     *   result of the input, false otherwise.\n     */\n    input(char) {\n        // Ignore additional input if the cursor's at the end of the pattern\n        if (this.selection.start === this.selection.end &&\n            this.selection.start === this.pattern.length) {\n            return false;\n        }\n        var selectionBefore = { ...this.selection };\n        var valueBefore = this.getValue();\n        var inputIndex = this.selection.start;\n        // If the cursor or selection is prior to the first editable character, make\n        // sure any input given is applied to it.\n        if (inputIndex < this.pattern.firstEditableIndex) {\n            inputIndex = this.pattern.firstEditableIndex;\n        }\n        // Bail out or add the character to input\n        if (this.pattern.isEditableIndex(inputIndex)) {\n            if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n                return false;\n            }\n            this.value[inputIndex] = this.pattern.transform(char, inputIndex);\n        }\n        // If multiple characters were selected, blank the remainder out based on the\n        // pattern.\n        var end = this.selection.end - 1;\n        while (end > inputIndex) {\n            if (this.pattern.isEditableIndex(end)) {\n                this.value[end] = this.placeholderChar;\n            }\n            end--;\n        }\n        // Advance the cursor to the next character\n        this.selection.start = this.selection.end = inputIndex + 1;\n        // Skip over any subsequent static characters\n        while (this.pattern.length > this.selection.start &&\n            !this.pattern.isEditableIndex(this.selection.start)) {\n            this.selection.start++;\n            this.selection.end++;\n        }\n        // History\n        if (this._historyIndex != null) {\n            // Took more input after undoing, so blow any subsequent history away\n            this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n            this._historyIndex = null;\n        }\n        if (this._lastOp !== 'input' ||\n            selectionBefore.start !== selectionBefore.end ||\n            (this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start)) {\n            this._history.push({ value: valueBefore, selection: selectionBefore, lastOp: this._lastOp });\n        }\n        this._lastOp = 'input';\n        this._lastSelection = { ...this.selection };\n        return true;\n    }\n    /**\n     * Attempts to delete from the value based on the current cursor position or\n     * selection.\n     * @return {boolean} true if the value or selection changed as the result of\n     *   backspacing, false otherwise.\n     */\n    backspace() {\n        // If the cursor is at the start there's nothing to do\n        if (this.selection.start === 0 && this.selection.end === 0) {\n            return false;\n        }\n        var selectionBefore = { ...this.selection };\n        var valueBefore = this.getValue();\n        // No range selected - work on the character preceding the cursor\n        if (this.selection.start === this.selection.end) {\n            if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n                if (this.pattern.isRevealingMask) {\n                    this.value.splice(this.selection.start - 1);\n                }\n                else {\n                    this.value[this.selection.start - 1] = this.placeholderChar;\n                }\n            }\n            this.selection.start--;\n            this.selection.end--;\n        }\n        // Range selected - delete characters and leave the cursor at the start of the selection\n        else {\n            var end = this.selection.end - 1;\n            while (end >= this.selection.start) {\n                if (this.pattern.isEditableIndex(end)) {\n                    this.value[end] = this.placeholderChar;\n                }\n                end--;\n            }\n            this.selection.end = this.selection.start;\n        }\n        // History\n        if (this._historyIndex != null) {\n            // Took more input after undoing, so blow any subsequent history away\n            this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n        }\n        if (this._lastOp !== 'backspace' ||\n            selectionBefore.start !== selectionBefore.end ||\n            (this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start)) {\n            this._history.push({ value: valueBefore, selection: selectionBefore, lastOp: this._lastOp });\n        }\n        this._lastOp = 'backspace';\n        this._lastSelection = { ...this.selection };\n        return true;\n    }\n    /**\n     * Attempts to paste a string of input at the current cursor position or over\n     * the top of the current selection.\n     * Invalid content at any position will cause the paste to be rejected, and it\n     * may contain static parts of the mask's pattern.\n     * @param {string} input\n     * @return {boolean} true if the paste was successful, false otherwise.\n     */\n    paste(input) {\n        // This is necessary because we're just calling input() with each character\n        // and rolling back if any were invalid, rather than checking up-front.\n        var initialState = {\n            value: this.value.slice(),\n            selection: { ...this.selection },\n            _lastOp: this._lastOp,\n            _history: this._history.slice(),\n            _historyIndex: this._historyIndex,\n            _lastSelection: { ...this._lastSelection },\n        };\n        // If there are static characters at the start of the pattern and the cursor\n        // or selection is within them, the static characters must match for a valid\n        // paste.\n        if (this.selection.start < this.pattern.firstEditableIndex) {\n            for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n                if (input.charAt(i) !== this.pattern.pattern[i]) {\n                    return false;\n                }\n            }\n            // Continue as if the selection and input started from the editable part of\n            // the pattern.\n            input = input.substring(this.pattern.firstEditableIndex - this.selection.start);\n            this.selection.start = this.pattern.firstEditableIndex;\n        }\n        for (i = 0, l = input.length; i < l && this.selection.start <= this.pattern.lastEditableIndex; i++) {\n            var valid = this.input(input.charAt(i));\n            // Allow static parts of the pattern to appear in pasted input - they will\n            // already have been stepped over by input(), so verify that the value\n            // deemed invalid by input() was the expected static character.\n            if (!valid) {\n                if (this.selection.start > 0) {\n                    // XXX This only allows for one static character to be skipped\n                    var patternIndex = this.selection.start - 1;\n                    if (!this.pattern.isEditableIndex(patternIndex) &&\n                        input.charAt(i) === this.pattern.pattern[patternIndex]) {\n                        continue;\n                    }\n                }\n                Object.keys(initialState).forEach(key => {\n                    // @ts-ignore\n                    this[key] = initialState[key];\n                });\n                return false;\n            }\n        }\n        return true;\n    }\n    undo() {\n        // If there is no history, or nothing more on the history stack, we can't undo\n        if (this._history.length === 0 || this._historyIndex === 0) {\n            return false;\n        }\n        var historyItem;\n        if (this._historyIndex == null) {\n            // Not currently undoing, set up the initial history index\n            this._historyIndex = this._history.length - 1;\n            historyItem = this._history[this._historyIndex];\n            // Add a new history entry if anything has changed since the last one, so we\n            // can redo back to the initial state we started undoing from.\n            var value = this.getValue();\n            if (historyItem.value !== value ||\n                historyItem.selection.start !== this.selection.start ||\n                historyItem.selection.end !== this.selection.end) {\n                this._history.push({\n                    value: value,\n                    selection: { ...this.selection },\n                    lastOp: this._lastOp,\n                    startUndo: true,\n                });\n            }\n        }\n        else {\n            historyItem = this._history[--this._historyIndex];\n        }\n        this.value = historyItem.value.split('');\n        this.selection = historyItem.selection;\n        this._lastOp = historyItem.lastOp;\n        return true;\n    }\n    redo() {\n        if (this._history.length === 0 || this._historyIndex == null) {\n            return false;\n        }\n        var historyItem = this._history[++this._historyIndex];\n        // If this is the last history item, we're done redoing\n        if (this._historyIndex === this._history.length - 1) {\n            this._historyIndex = null;\n            // If the last history item was only added to start undoing, remove it\n            if (historyItem.startUndo) {\n                this._history.pop();\n            }\n        }\n        this.value = historyItem.value.split('');\n        this.selection = historyItem.selection;\n        this._lastOp = historyItem.lastOp;\n        return true;\n    }\n    setSelection(selection) {\n        this.selection = { ...selection };\n        if (this.selection.start === this.selection.end) {\n            if (this.selection.start < this.pattern.firstEditableIndex) {\n                this.selection.start = this.selection.end = this.pattern.firstEditableIndex;\n                return true;\n            }\n            // Set selection to the first editable, non-placeholder character before the selection\n            // OR to the beginning of the pattern\n            var index = this.selection.start;\n            while (index >= this.pattern.firstEditableIndex) {\n                if ((this.pattern.isEditableIndex(index - 1) &&\n                    this.value[index - 1] !== this.placeholderChar) ||\n                    index === this.pattern.firstEditableIndex) {\n                    this.selection.start = this.selection.end = index;\n                    break;\n                }\n                index--;\n            }\n            return true;\n        }\n        return false;\n    }\n}\nInputMask.Pattern = Pattern;\nexport default InputMask;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRtYXNrLWNvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2lucHV0bWFzay1jb3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx3QkFBd0IsRUFBb0IscUJBQXFCLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDOUYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQWFwQyxNQUFNLE9BQU8sU0FBUztJQXFCcEIsWUFBWSxPQUF5QjtRQVpyQyxlQUFVLEdBQUcsRUFBRSxDQUFDO1FBRWhCLGFBQVEsR0FLRixFQUFFLENBQUM7UUFDVCxrQkFBYSxHQUFrQixJQUFJLENBQUM7UUFDcEMsWUFBTyxHQUFrQixJQUFJLENBQUM7UUFDOUIsbUJBQWMsR0FBMkIsSUFBSSxDQUFDO1FBRzVDLE1BQU0sYUFBYSxHQUFZO1lBQzdCLEdBQUc7Z0JBQ0QsZUFBZSxFQUFFLEtBQUs7Z0JBQ3RCLGVBQWUsRUFBRSx3QkFBd0I7Z0JBQ3pDLFNBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRTtnQkFDL0IsS0FBSyxFQUFFLEVBQUU7YUFDVjtZQUNELEdBQUcsT0FBTztTQUNBLENBQUM7UUFFYixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxJQUNFLE9BQU8sYUFBYSxDQUFDLGVBQWUsS0FBSyxRQUFRO1lBQ2pELGFBQWEsQ0FBQyxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFDeEM7WUFDQSxNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLGFBQWEsQ0FBQyxlQUFlLENBQUM7UUFDckQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTlFLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRTtZQUNyQyxLQUFLLEVBQUUsYUFBYSxDQUFDLEtBQUs7WUFDMUIsU0FBUyxFQUFFLGFBQWEsQ0FBQyxTQUFTO1lBQ2xDLGVBQWUsRUFBRSxhQUFhLENBQUMsZUFBZTtTQUMvQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsVUFBVSxDQUFDLGFBQXFCLEVBQUUsT0FBeUI7UUFDekQsTUFBTSxNQUFNLEdBQUc7WUFDYixTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7WUFDL0IsS0FBSyxFQUFFLEVBQUU7WUFDVCxHQUFHLE9BQU87U0FDWCxDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FDeEIsYUFBYSxFQUNiLElBQUksQ0FBQyxnQkFBZ0IsRUFDckIsSUFBSSxDQUFDLGVBQWUsRUFDcEIsTUFBTSxDQUFDLGVBQWUsQ0FDdkIsQ0FBQztRQUVGLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVELFFBQVEsQ0FBQyxLQUFjO1FBQ3JCLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtZQUNqQixLQUFLLEdBQUcsRUFBRSxDQUFDO1NBQ1o7UUFDRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsYUFBYTtRQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ25CLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUM5QyxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUU7WUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFO2dCQUM3QyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM5QjtTQUNGO1FBQ0QsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxJQUFZO1FBQ2hCLG9FQUFvRTtRQUNwRSxJQUNFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRztZQUMzQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFDNUM7WUFDQSxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsSUFBSSxlQUFlLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQXFCLENBQUM7UUFDL0QsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWxDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBRXRDLDRFQUE0RTtRQUM1RSx5Q0FBeUM7UUFDekMsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBbUIsRUFBRTtZQUNqRCxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBbUIsQ0FBQztTQUMvQztRQUVELHlDQUF5QztRQUN6QyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLEVBQUU7Z0JBQ2xELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztTQUNuRTtRQUVELDZFQUE2RTtRQUM3RSxXQUFXO1FBQ1gsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sR0FBRyxHQUFHLFVBQVUsRUFBRTtZQUN2QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7YUFDeEM7WUFDRCxHQUFHLEVBQUUsQ0FBQztTQUNQO1FBRUQsMkNBQTJDO1FBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFFM0QsNkNBQTZDO1FBQzdDLE9BQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLO1lBQzFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFDbkQ7WUFDQSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDdEI7UUFFRCxVQUFVO1FBQ1YsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksRUFBRTtZQUM5QixxRUFBcUU7WUFDckUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDcEYsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7U0FDM0I7UUFDRCxJQUNFLElBQUksQ0FBQyxPQUFPLEtBQUssT0FBTztZQUN4QixlQUFlLENBQUMsS0FBSyxLQUFLLGVBQWUsQ0FBQyxHQUFHO1lBQzdDLENBQUMsSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLElBQUksZUFBZSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUNyRjtZQUNBLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUM5RjtRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUU1QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFNBQVM7UUFDUCxzREFBc0Q7UUFDdEQsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFO1lBQzFELE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxJQUFJLGVBQWUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzVDLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVsQyxpRUFBaUU7UUFDakUsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUMvQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUMxRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFO29CQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDN0M7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO2lCQUM3RDthQUNGO1lBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3RCO1FBQ0Qsd0ZBQXdGO2FBQ25GO1lBQ0gsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7aUJBQ3hDO2dCQUNELEdBQUcsRUFBRSxDQUFDO2FBQ1A7WUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztTQUMzQztRQUVELFVBQVU7UUFDVixJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxFQUFFO1lBQzlCLHFFQUFxRTtZQUNyRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNyRjtRQUNELElBQ0UsSUFBSSxDQUFDLE9BQU8sS0FBSyxXQUFXO1lBQzVCLGVBQWUsQ0FBQyxLQUFLLEtBQUssZUFBZSxDQUFDLEdBQUc7WUFDN0MsQ0FBQyxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksSUFBSSxlQUFlLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQ3JGO1lBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQzlGO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUM7UUFDM0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBRTVDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsS0FBYTtRQUNqQiwyRUFBMkU7UUFDM0UsdUVBQXVFO1FBQ3ZFLElBQUksWUFBWSxHQUFHO1lBQ2pCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTtZQUN6QixTQUFTLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUMvQixhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWE7WUFDakMsY0FBYyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFO1NBQzNDLENBQUM7UUFFRiw0RUFBNEU7UUFDNUUsNEVBQTRFO1FBQzVFLFNBQVM7UUFDVCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQW1CLEVBQUU7WUFDM0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQW1CLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdkYsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUMvQyxPQUFPLEtBQUssQ0FBQztpQkFDZDthQUNGO1lBRUQsMkVBQTJFO1lBQzNFLGVBQWU7WUFDZixLQUFLLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFtQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBbUIsQ0FBQztTQUN6RDtRQUVELEtBQ0UsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFDdkIsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFrQixFQUNoRSxDQUFDLEVBQUUsRUFDSDtZQUNBLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLDBFQUEwRTtZQUMxRSxzRUFBc0U7WUFDdEUsK0RBQStEO1lBQy9ELElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1YsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUU7b0JBQzVCLDhEQUE4RDtvQkFDOUQsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO29CQUM1QyxJQUNFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDO3dCQUMzQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUN0RDt3QkFDQSxTQUFTO3FCQUNWO2lCQUNGO2dCQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUN0QyxhQUFhO29CQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2hDLENBQUMsQ0FBQyxDQUFDO2dCQUVILE9BQU8sS0FBSyxDQUFDO2FBQ2Q7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELElBQUk7UUFDRiw4RUFBOEU7UUFDOUUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxDQUFDLEVBQUU7WUFDMUQsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELElBQUksV0FBVyxDQUFDO1FBQ2hCLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLEVBQUU7WUFDOUIsMERBQTBEO1lBQzFELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQzlDLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNoRCw0RUFBNEU7WUFDNUUsOERBQThEO1lBQzlELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM1QixJQUNFLFdBQVcsQ0FBQyxLQUFLLEtBQUssS0FBSztnQkFDM0IsV0FBVyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLO2dCQUNwRCxXQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFDaEQ7Z0JBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7b0JBQ2pCLEtBQUssRUFBRSxLQUFLO29CQUNaLFNBQVMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtvQkFDaEMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO29CQUNwQixTQUFTLEVBQUUsSUFBSTtpQkFDaEIsQ0FBQyxDQUFDO2FBQ0o7U0FDRjthQUFNO1lBQ0wsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbkQ7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFDbEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsSUFBSTtRQUNGLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxFQUFFO1lBQzVELE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3RELHVEQUF1RDtRQUN2RCxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ25ELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQzFCLHNFQUFzRTtZQUN0RSxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDckI7U0FDRjtRQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUNsQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxZQUFZLENBQUMsU0FBMEI7UUFDckMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUcsU0FBUyxFQUFFLENBQUM7UUFFbEMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUMvQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQW1CLEVBQUU7Z0JBQzNELElBQUksQ0FBQyxTQUFVLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFVLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQTRCLENBQUM7Z0JBQ3hGLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCxzRkFBc0Y7WUFDdEYscUNBQXFDO1lBQ3JDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1lBQ2pDLE9BQU8sS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQW1CLEVBQUU7Z0JBQ2hELElBQ0UsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO29CQUN0QyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsZUFBZSxDQUFDO29CQUNqRCxLQUFLLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFDekM7b0JBQ0EsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO29CQUNsRCxNQUFNO2lCQUNQO2dCQUNELEtBQUssRUFBRSxDQUFDO2FBQ1Q7WUFDRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOztBQW5ZTSxpQkFBTyxHQUFHLE9BQU8sQ0FBQztBQXNZM0IsZUFBZSxTQUFTLENBQUMifQ=="]},"metadata":{},"sourceType":"module"}